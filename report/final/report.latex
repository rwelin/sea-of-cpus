\documentclass[a4paper,twoside,11pt]{article}
\usepackage{fullpage}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage[british]{babel}
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage{pdflscape}
\usepackage{tikz}

\usepackage[
  style=apa,
  backend=biber,
  urldate=iso8601]{biblatex}
\addbibresource{sources.bib}
\bibliography{sources}
\DeclareLanguageMapping{british}{british-apa}

% Setup source code listings
\usepackage{courier}

\usepackage{color}
\definecolor{cred}{rgb}{0.9,0.1,0.25}
\definecolor{cgreen}{rgb}{0.05,0.5,0.1}
\definecolor{ccyan}{rgb}{0.1,0.6,0.8}
\definecolor{cmagenta}{rgb}{0.7,0.1,0.2}
\definecolor{cyellow}{rgb}{0.7,0.4,0}
\definecolor{cgray}{rgb}{0.5,0.5,0.5}
\definecolor{clightlightgray}{gray}{1.0}

\usepackage{listings}
\lstset{
  language={[x86masm]Assembler},
  basicstyle=\footnotesize\ttfamily,    % Standardschrift
  tabsize=4,                            % Groesse von Tabs
  extendedchars=true,                   %
  breaklines=true,                      % Zeilen werden Umgebrochen
  frame=b,
  backgroundcolor=\color{clightlightgray},
  %backgroundcolor=\color{cgray},
  keywordstyle=\color{cmagenta}\bfseries,
  stringstyle=\color{cyellow},
  commentstyle=\color{cgreen},
  showspaces=false,                     % Leerzeichen anzeigen ?
  showtabs=false,                       % Tabs anzeigen ?
  xleftmargin=17pt,
  framexleftmargin=17pt,
  framexrightmargin=5pt,
  framexbottommargin=4pt,
  showstringspaces=false                % Leerzeichen in Strings anzeigen ?
}

\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}
{\colorbox[cmyk]{0.43,0.35,0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{ format=listing,
  labelfont=white,
  textfont=white,
  singlelinecheck=false,
  margin=0pt,
  font={bf,sf,small}
}

\def\name{Robert Welin}
\def\prjtitle{Sea-of-CPUs on an FPGA}
\def\cid{00656261}

% Title info
\markboth{}{\name: \prjtitle}

\begin{document}

\begin{titlepage}
% \newgeometry{top=25mm,bottom=25mm,left=38mm,right=32mm}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt}
% \fontfamily{phv}\selectfont

{
\Large
\raggedright
Imperial College London\\[17pt]
Department of Electrical and Electronic Engineering\\[17pt]
Final Year Project Report 2014\\[17pt]

}
\rule{\columnwidth}{3pt}

\vfill

\centering
% \includegraphics[width=0.7\columnwidth,height=60mm,keepaspectratio]{imgs/MyRobot.jpg}

\vfill

\setlength{\tabcolsep}{0pt}
\begin{tabular}{p{40mm}p{\dimexpr\columnwidth-40mm}}
Project Title: & \textbf{\prjtitle} \\[12pt]
Student: & \textbf{\name} \\[12pt]
CID: & \textbf{00656261} \\[12pt]
Course: & \textbf{EIE4} \\[12pt]
Project Supervisor: & \textbf{Dr D.B. Thomas} \\[12pt]
Second Marker: & \textbf{Dr K. Nikolic} \\
\end{tabular}
\end{titlepage}


\section{Introduction}

\section{Background}

\subsection{Instruction set architectures}

The instruction set architecture (ISA) of a processor can be considered the software interface of the processor.
It provides the programmer or compiler writer a definition of commands that can be issued to the machine, so called opcodes or machine instructions.
The ISA also describes the structure of these opcodes such as length and the information contained in the opcode.
This could be the registers used in the operation, memory locations or specific addressing modes.

ISAs are generally divided into two big classes: complex instruction set computer (CISC) and reduced instruction set computer (RISC).
CISC usually features variable length instructions with complex effects, whereas RISC architectures has fixed length instructions with a single effect.
Modern CISC architectures such as x86 are known for being relatively simple to program at the cost of larger, more complex hardware.
Conversely, RISC designs such as MIPS are very small, but require more machine instructions to accomplish the same task as a CISC architecture, resulting in larger programs and a more complex compilers.

Both types of processors usually follow the same architectural pattern with the following four stages:

\begin{enumerate}
    \item \emph{Instruction decode} -- load instruction word from memory and identify the operation and any associated operands.
    \item \emph{Data fetch} -- use the operands of the instruction to fetch any data needed to perform the desired calculation.
    \item \emph{Execution} -- perform the arithmetic or other operation on the fetched data.
    \item \emph{Write back} -- store the result from the execution stage.
\end{enumerate}


\subsubsection{Addressing modes}

Addressing modes are descriptions of how the operands in a given machine instruction are used to calculate a memory address.
There are several commonly used addressing modes, each with their advantages and disadvantages.

\begin{itemize}
    \item \emph{Absolute addressing} uses an operand in the instruction word as a direct address without any modification.
      This mode usually requires an operand that is large enough to cover the entire address space of the processor,
      which might be impossible for ISAs with very short instruction words.

    \item \emph{Register indirect addressing} uses an operand as a register index.
      The content of the register is then used as a memory address.

    \item \emph{PC relative addressing} calculates an address from adding a constant to the value of the program counter.
      Since computer programs have a lot of spacial locality, 90\% of all branches can be calculated using PC relative addressing and an offset of as little as 8 bits.

\end{itemize}


\subsection{Micro architectures}

The microarchitecture of a processors refers to a specific implementation of a instruction set architecture.

\subsection{DSP48E1 slice}

\begin{figure}
  \caption{Diagram of the DSP48E1 slice \parencite{dsp48e1}}
  \label{fig:dsp48e1}
  \includegraphics[width=\linewidth]{dsp48e1}
\end{figure}


\subsection{Related work}

- Other attempts at soft-processors
  - Microblaze, picoblaze
  - SIMD processors
  - DSP block focused processors
- MPPAs

\subsection{Hardware capabilities}

\subsubsection{DSP48E1 Slice}

\subsubsection{Block RAM}

\section{Design}

The design had of the processor had to take several aspects into account.

\begin{itemize}
    \item As it was going to be target on an FPGA, the dedicated logic in the form of block RAMs and DSP slices had to be used effectively.
    \item The implementation had to a relatively few number of LUTs in order to accommodate for the ratio between LUTs and other dedicated logic.
    \item The processor had to run at a relatively high clock frequency.
\end{itemize}

%- Proof of concept processor:
%  - Arithmetic instructions that prove points
%  - useful branch instructions and mov





\subsection{Instruction set architecture}

The different instruction types of the instruction set architecture are shown in table \ref{t:instruction-types}.

\begin{table}
\centering
\caption{Instruction types}
\label{t:instruction-types}
\newcommand{\const}{\multicolumn{2}{c|}{const}}
\begin{tabular}{| l | l | l | l |}
    \hline
    Type    & \multicolumn{3}{c|}{format}       \\ \hline
            & [17:12]   &   [11:6]  &   [5:0]   \\ \hline
    1       & op        &   -       &   -       \\ \hline
    2       & op        &   \const              \\ \hline
    3       & op        &   reg     &   -       \\ \hline
    4       & op        &   -       &   reg     \\ \hline
    5       & op        &   reg     &   reg     \\ \hline
    6       & op        &   reg     &   const   \\ \hline
\end{tabular}
\end{table}


\begin{table}
\centering
\caption{Instruction set}
\label{t:instruction-set}
\newcommand{\const}{\multicolumn{2}{c|}{const}}
\begin{tabular}{| l | l | l | l |}
    \hline
    \multicolumn{3}{|c|}{Format}       &   Description             \\ \hline
    [17:12]     &   [11:6]  &   [5:0]   &                           \\ \hline
    nop         &   -       &   -       &   Does nothing            \\ \hline
    mova        &   \const              &   acc := const            \\ \hline
    movar       &   ra      &   -       &   acc := ra               \\ \hline
    movra       &   ra      &   -       &   ra := acc               \\ \hline
    movr        &   ra      &   const   &   ra := const             \\ \hline
    movrr       &   ra      &   rb      &   ra := rb                \\ \hline
    lda         &   \const              &   acc := [const]          \\ \hline
    sta         &   \const              &   [const] := acc          \\ \hline
    ldar        &   ra      &   -       &   acc := [ra]             \\ \hline
    star        &   ra      &   -       &   [ra] := acc             \\ \hline
    ldrr        &   ra      &   rb      &   ra := [rb]              \\ \hline
    strr        &   ra      &   rb      &   [ra] := rb              \\ \hline
    adda        &   \const              &   acc := acc + const      \\ \hline
    suba        &   \const              &   acc := acc - const      \\ \hline
    addar       &   ra      &   const   &   ra := ra + const        \\ \hline
    subar       &   ra      &   const   &   ra := ra - const        \\ \hline
    addr        &   ra      &   rb      &   ra := ra + rb           \\ \hline
    subr        &   ra      &   rb      &   ra := ra - rb           \\ \hline
    addrm       &   ra      &   rb      &   ra := ra + [rb]         \\ \hline
    subrm       &   ra      &   rb      &   ra := ra - [rb]         \\ \hline
    mulr        &   ra      &   const   &   ra := ra * const        \\ \hline
    mulrr       &   ra      &   rb      &   ra := ra * rb           \\ \hline
    mulrm       &   ra      &   rb      &   ra := ra * [rb]         \\ \hline
    mac         &   ra      &   rb      &   acc := acc + ra * [rb]  \\ \hline
    macp        &   ra      &   rb      &   acc := p + ra * rb      \\ \hline
    macpm       &   ra      &   rb      &   acc := p + ra * [rb]    \\ \hline
    coefa       &   \const              &   coefa := const          \\ \hline
    dataa       &   \const              &   dataa := const          \\ \hline
    datao       &   \const              &   datao := const          \\ \hline
    datam       &   \const              &   datam := const          \\ \hline
    cmac        &   -       &   -       &   acc := p + [coefa++] * [dataa++] \\ \hline
    cstr        &   ra:6    &   -       &   datao := (datao-1) mod (datam+1); [dataa+datao] := ra \\ \hline
    j           &   \const              &   pc := const             \\ \hline
    br          &   -       &   rb      &   pc := rb                \\ \hline
    bz          &   ra      &   rb      &   if ra = 0: pc := rb     \\ \hline
    bnz         &   ra      &   rb      &   if ra != 0: pc := rb    \\ \hline
    bnzd        &   ra      &   rb      &   if ra != 0: pc := rb; ra := ra - 1 \\ \hline
    bltz        &   ra      &   rb      &   if rb < 0: pc := rb     \\ \hline
    bgez        &   ra      &   rb      &   if rb >= 0: pc := rb    \\ \hline
    call        &   ra      &   rb      &   ra := pc + 7; pc := rb  \\ \hline
    movrf       &   ra      &   index   &   push back ra to output[index] \\ \hline
    movfr       &   ra      &   index   &   pop front of input[index] \\ \hline
\end{tabular}
\end{table}

\section{Implementation}

\subsection{Tools}

\subsubsection{Assembler}

\subsubsection{Array generator}

Due to the Xilinx tools lack of support for versions of VHDL later than VHDL 1993, a program had to be written in order to generate large configurations of processor cores.
The resulting program, called \texttt{mkarray}, takes a topology and a size as arguments and outputs a VHDL entity.
The entity instantiates the given number of cores, connected according to the given topology.

Two configurations were implemented: a one directional chain and a two-dimensional grid pattern with bi-directional communication.
These can be seen in listing \ref{l-mkarray-sample}.

Since the configurations are simply expressed using Python, additional topologies can easily be expressed.

\lstinputlisting[
  language=python,
  label=l-mkarray-sample,
caption={Chain and grid implementations in \texttt{mkarray}}]
  {mkarray-sample.py}

\section{Result}

%- Communication bandwidth
%- Cycle count for programs
%  - FIR
%  - Fibonacci
%  -
%- Size with varying number of fifos
%- Clock rate impact with different number of cores


\section{Discussion}

%- Pipeline too long with no benefit (extra hardware)
%- Low clock frequency
%- Instruction set should be bigger (shifts, compare, bitwise ops)
\subsection{Missing functionality}

Although the processor used the arithmetic operations of the DSP48E1 slice effectively, it did not take advantage of its bitwise operations.
These would have been a useful addition for applications like cryptography where the exclusive-or operation is frequently used.

%- Simultaneous multi threading because nops

\section{Conclusion}

\end{document}
