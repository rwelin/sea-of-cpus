\documentclass[a4paper,twoside,11pt]{article}
\usepackage{fullpage}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage[british]{babel}
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage{pdflscape}
\usepackage{tikz}

\usepackage[
  style=apa,
  backend=biber,
  urldate=iso8601]{biblatex}
\addbibresource{sources.bib}
\bibliography{sources}
\DeclareLanguageMapping{british}{british-apa}

% Setup source code listings
\usepackage{courier}

\usepackage{color}
\definecolor{cred}{rgb}{0.9,0.1,0.25}
\definecolor{cgreen}{rgb}{0.05,0.5,0.1}
\definecolor{ccyan}{rgb}{0.1,0.6,0.8}
\definecolor{cmagenta}{rgb}{0.7,0.1,0.2}
\definecolor{cyellow}{rgb}{0.7,0.4,0}
\definecolor{cgray}{rgb}{0.5,0.5,0.5}
\definecolor{clightlightgray}{gray}{1.0}

\usepackage{listings}
\lstset{
  language={[x86masm]Assembler},
  basicstyle=\footnotesize\ttfamily,    % Standardschrift
  tabsize=4,                            % Groesse von Tabs
  extendedchars=true,                   %
  breaklines=true,                      % Zeilen werden Umgebrochen
  frame=b,
  backgroundcolor=\color{clightlightgray},
  %backgroundcolor=\color{cgray},
  keywordstyle=\color{cmagenta}\bfseries,
  stringstyle=\color{cyellow},
  commentstyle=\color{cgreen},
  showspaces=false,                     % Leerzeichen anzeigen ?
  showtabs=false,                       % Tabs anzeigen ?
  xleftmargin=17pt,
  framexleftmargin=17pt,
  framexrightmargin=5pt,
  framexbottommargin=4pt,
  showstringspaces=false                % Leerzeichen in Strings anzeigen ?
}

\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}
{\colorbox[cmyk]{0.43,0.35,0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{ format=listing,
  labelfont=white,
  textfont=white,
  singlelinecheck=false,
  margin=0pt,
  font={bf,sf,small}
}

\def\name{Robert Welin}
\def\prjtitle{Sea-of-CPUs on an FPGA}
\def\cid{00656261}

% Title info
\markboth{}{\name: \prjtitle}

\begin{document}

\begin{titlepage}
% \newgeometry{top=25mm,bottom=25mm,left=38mm,right=32mm}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt}
% \fontfamily{phv}\selectfont

{
\Large
\raggedright
Imperial College London\\[17pt]
Department of Electrical and Electronic Engineering\\[17pt]
Final Year Project Report 2014\\[17pt]

}
\rule{\columnwidth}{3pt}

\vfill

\centering
% \includegraphics[width=0.7\columnwidth,height=60mm,keepaspectratio]{imgs/MyRobot.jpg}

\vfill

\setlength{\tabcolsep}{0pt}
\begin{tabular}{p{40mm}p{\dimexpr\columnwidth-40mm}}
Project Title: & \textbf{\prjtitle} \\[12pt]
Student: & \textbf{\name} \\[12pt]
CID: & \textbf{00656261} \\[12pt]
Course: & \textbf{EIE4} \\[12pt]
Project Supervisor: & \textbf{Dr D.B. Thomas} \\[12pt]
Second Marker: & \textbf{Dr K. Nikolic} \\
\end{tabular}
\end{titlepage}


\section{Introduction}

FPGAs have for a long time been a desirable platform because of their excellent flexibility and relatively good performance.
Over the last few year, however, the demand for special purpose hardware primitives on the FPGA for ubiquitous operations such as multiply-accumulate has increased rapidly.
Modern FPGAs have therefore become increasingly complex, with large amounts of traditional configurable logic, RAM blocks and dedicated DSP units.

The aim of the project is to design and implement a small, independent soft processor that utilise these resources.
A large number of these CPUs should be instantiated on a single FPGA, forming a large processor array that can co-operate to solve larger, parallel tasks.

\section{Background}

\subsection{Instruction set architectures}

The instruction set architecture (ISA) of a processor can be considered the software interface of the processor.
It provides the programmer or compiler writer a definition of commands that can be issued to the machine, so called opcodes or machine instructions.
The ISA also describes the structure of these opcodes such as length and the information contained in the opcode.
This could be the registers used in the operation, memory locations or specific addressing modes. \parencite[pp 22]{comp-arch-organization}

ISAs are generally divided into two big classes: complex instruction set computer (CISC) and reduced instruction set computer (RISC).
CISC usually features variable length instructions with complex effects, whereas RISC architectures has fixed length instructions with a single effect.
Modern CISC architectures such as x86 are known for being relatively simple to program at the cost of larger, more complex hardware.
Conversely, RISC designs such as MIPS are very small, but require more machine instructions to accomplish the same task as a CISC architecture, resulting in larger programs and a more complex compilers.

Both types of processors usually follow the same architectural pattern with the following four stages:

\begin{enumerate}
    \item \emph{Instruction decode} -- load instruction word from memory and identify the operation and any associated operands.
    \item \emph{Data fetch} -- use the operands of the instruction to fetch any data needed to perform the desired calculation.
    \item \emph{Execution} -- perform the arithmetic or other operation on the fetched data.
    \item \emph{Write back} -- store the result from the execution stage.
\end{enumerate}

In addition, instruction set architectures are further classified by how data is fetched and executed upon.

\begin{itemize}
    \item \emph{Accumulator architecture} -- uses a single register that stores intermediate results.
    \item \emph{Load/store architecture} -- data is fetched from main memory into registers.
        Arithmetic and logic operations only operate on registers.
        This type is very common among RISC architectures such as MIPS and ARM \parencite[pp 9-12]{flynn1995computer}.
    \item \emph{Register memory architecture} -- operands can be used as memory addresses in order to fetch data from main memory and perform the operation on the data directly,
        without having to store the data in a register first.
        The x86 architecture is a well known register memory architecture \parencite[pp 9-12]{flynn1995computer}.

\end{itemize}



\subsubsection{Addressing modes}

When accessing data from memory, a memory address has to be encoded in the machine instruction.
Addressing modes are descriptions of how the operands in a given machine instruction are used to calculate a memory address.
There are several commonly used addressing modes, each with their advantages and disadvantages.

\begin{itemize}
    \item \emph{Absolute addressing} uses an operand in the instruction word as a direct address without any modification.
      This mode usually requires an operand that is large enough to cover the entire address space of the processor,
      which might be impossible for ISAs with very short instruction words.

    \item \emph{Register indirect addressing} uses an operand as a register index.
      The content of the register is then used as a memory address.

    \item \emph{PC relative addressing} calculates an address from adding a constant to the value of the program counter.
      Since computer programs have a lot of spacial locality, 90\% of all branches can be calculated using PC relative addressing and an offset of as little as 8 bits \parencite{isa-design-1995}.

\end{itemize}

\subsection{Micro architectures}

The microarchitecture of a processors refers to a specific implementation of an instruction set architecture.
Since the aim of this project is to effectively utilise the hardware on the FPGA, the microarchitecture is very influential on the resulting ISA.

\subsubsection{DSP48E1 Slice}

Figure \ref{fig:dsp48e1} shows a diagram of the embedded Xilinx DSP48E1 slice.
It can perform a large number of different arithmetic and logic operations and is configurable on a per-cycle basis.

The block consists of three main parts: the pre-adder, the multiplier and the ALU.
It has four main data inputs: A, B, C and D and three configuration inputs that control the ALU (ALUMODE), the inputs to the ALU (OPMODE) and the function of the pre-adder and multiplier inputs (INMODE).
The pre-adder allows for two of the data inputs (A and D) to be added or subtracted before the resulting signal enters the multiplier.
The multiplier performs a multiplication on the output of the pre-adder and the B input.
The final stage in the DSP slice is the ALU which can take a number of different inputs and perform addition, subtraction and various logic operations.
The inputs include the C input, the output of the multiplier and inputs A and B concatenated.
All these inputs and operations are configurable on every clock cycle which makes it a very flexible hardware block. \parencite{dsp48e1}


\begin{figure}
  \centering
  \caption{Diagram of the DSP48E1 slice \parencite[pp 8]{dsp48e1}}
  \label{fig:dsp48e1}
  \includegraphics[width=\linewidth]{dsp48e1}
\end{figure}

\subsubsection{Block RAM}

Figure \ref{fig:bram} shows a diagram of the Xilinx 36kb block RAM.
The block RAM can be configured in many ways, including the word size and memory width, different port configurations (e.g. single port, true dual port) and clock inputs.

\begin{figure}
  \centering
  \caption{Diagram of the 36kb block RAM \parencite[pp 14]{memory}}
  \label{fig:bram}
  \includegraphics[width=0.5\textwidth]{bram}
\end{figure}

\subsection{Related work}

FPGAs have historically been used for accelerating algorithms by creating custom pipelined, parallel processors, often called hard-core processors.
However, many programs are more suited for software implementations, and it has therefore become more and more common to use soft-core processors along with the accelerator hardware or standalone.
Many commercial soft-processors are available including the Xilinx PicoBlaze microcontroller \parencite{picoblaze}, the Xilinx MicroBlaze \parencite{microblaze} and the Altera Nios II processor \parencite{nios2}.

In research, many different kinds of soft processors have been proposed.
These include multithreaded processors such as \parencite{octavo-2012} and \parencite{custard} which has automatically generated custom instructions.
Various VLIW processors have also been developed such as \parencite{vliw} which has runtime configurable number of issue slots.
Vector processors have also been attempted multiple times \parencite{ultra-fine-2009}\parencite{vespa}.

With the recent addition of special purpose hardware such as the Xilinx DSP48E1 slice, research into soft-processors that utilise these resources has become increasingly popular.
\cite{cheah2012lean} created a small processor that showcased the capabilities of a single DSP slice.
They later, developed this into a complete processor \parencite{idea-2012}.

There has also been research into multicore architectures such as \parencite{mora-2009} and \parencite{fpga-simd}.
However, only the latter takes advantage of embedded DSP blocks.



%- Other attempts at soft-processors
%  - Microblaze, picoblaze
%  - SIMD processors
%  - DSP block focused processors
%- MPPAs


\section{Design}

The design had of the processor had to take several aspects into account.

\begin{itemize}
    \item As it was going to be target on an FPGA, the dedicated logic in the form of block RAMs and DSP slices had to be used effectively.
    \item The implementation had to a relatively few number of LUTs in order to accommodate for the ratio between LUTs and other dedicated logic.
    \item The processor had to run at a relatively high clock frequency.
    \item It had to have an instruction set that allowed for good performing DSP programs such as FIR filters, but also allowed for more general computations.
\end{itemize}


%- Proof of concept processor:
%  - Arithmetic instructions that prove points
%  - useful branch instructions and mov





\subsection{Instruction set architecture}

The first constraint on the instruction set architecture was the size of the instruction word.
Since a single block RAM was going to be used as main memory, the instruction word had to be a possible word width of the RAM in order utilise it efficiently.

The different instruction types of the instruction set architecture are shown in table \ref{t:instruction-types}.

\begin{table}
\centering
\caption{Instruction types}
\label{t:instruction-types}
\newcommand{\const}{\multicolumn{2}{c|}{const}}
\begin{tabular}{| l | l | l | l |}
    \hline
    Type    & \multicolumn{3}{c|}{format}       \\ \hline
            & [17:12]   &   [11:6]  &   [5:0]   \\ \hline
    1       & op        &   -       &   -       \\ \hline
    2       & op        &   \const              \\ \hline
    3       & op        &   reg     &   -       \\ \hline
    4       & op        &   -       &   reg     \\ \hline
    5       & op        &   reg     &   reg     \\ \hline
    6       & op        &   reg     &   const   \\ \hline
\end{tabular}
\end{table}


\begin{table}
\centering
\caption{Instruction set}
\label{t:instruction-set}
\newcommand{\const}{\multicolumn{2}{c|}{const}}
\begin{tabular}{| l | l | l | l |}
    \hline
    \multicolumn{3}{|c|}{Format}        &   Description             \\ \hline
    [17:12]     &   [11:6]  &   [5:0]   &                           \\ \hline
    nop         &   -       &   -       &   Does nothing            \\ \hline
    mova        &   \const              &   acc := const            \\ \hline
    movar       &   ra      &   -       &   acc := ra               \\ \hline
    movra       &   ra      &   -       &   ra := acc               \\ \hline
    movr        &   ra      &   const   &   ra := const             \\ \hline
    movrr       &   ra      &   rb      &   ra := rb                \\ \hline
    lda         &   \const              &   acc := [const]          \\ \hline
    sta         &   \const              &   [const] := acc          \\ \hline
    ldar        &   ra      &   -       &   acc := [ra]             \\ \hline
    star        &   ra      &   -       &   [ra] := acc             \\ \hline
    ldrr        &   ra      &   rb      &   ra := [rb]              \\ \hline
    strr        &   ra      &   rb      &   [ra] := rb              \\ \hline
    shfta       &   \const              &   acc := acc \textgreater\textgreater by const \\ \hline
    shftar      &   ra      &   -       &   acc := acc logical shift right by ra \\ \hline
    adda        &   \const              &   acc := acc + const      \\ \hline
    suba        &   \const              &   acc := acc - const      \\ \hline
    addar       &   ra      &   const   &   ra := ra + const        \\ \hline
    subar       &   ra      &   const   &   ra := ra - const        \\ \hline
    addr        &   ra      &   rb      &   ra := ra + rb           \\ \hline
    subr        &   ra      &   rb      &   ra := ra - rb           \\ \hline
    addrm       &   ra      &   rb      &   ra := ra + [rb]         \\ \hline
    subrm       &   ra      &   rb      &   ra := ra - [rb]         \\ \hline
    mulr        &   ra      &   const   &   ra := ra * const        \\ \hline
    mulrr       &   ra      &   rb      &   ra := ra * rb           \\ \hline
    mulrm       &   ra      &   rb      &   ra := ra * [rb]         \\ \hline
    mac         &   ra      &   rb      &   acc := acc + ra * [rb]  \\ \hline
    macp        &   ra      &   rb      &   acc := p + ra * rb      \\ \hline
    macpm       &   ra      &   rb      &   acc := p + ra * [rb]    \\ \hline
    coefa       &   \const              &   coefa := const          \\ \hline
    dataa       &   \const              &   dataa := const          \\ \hline
    datao       &   \const              &   datao := const          \\ \hline
    datam       &   \const              &   datam := const          \\ \hline
    cmac        &   -       &   -       &   acc := p + [coefa++] * [dataa++] \\ \hline
    cstr        &   ra      &   -       &   datao := (datao-1) mod (datam+1); [dataa+datao] := ra \\ \hline
    j           &   \const              &   pc := const             \\ \hline
    br          &   -       &   rb      &   pc := rb                \\ \hline
    bz          &   ra      &   rb      &   if $ra = 0$: pc := rb     \\ \hline
    bnz         &   ra      &   rb      &   if $ra \neq 0$: pc := rb    \\ \hline
    bnzd        &   ra      &   rb      &   if $ra \neq 0$: pc := rb; ra := ra - 1 \\ \hline
    bltz        &   ra      &   rb      &   if $rb < 0$: pc := rb     \\ \hline
    bgez        &   ra      &   rb      &   if $rb \ge 0$: pc := rb    \\ \hline
    call        &   ra      &   rb      &   ra := pc + 7; pc := rb  \\ \hline
    movrf       &   ra      &   index   &   push back ra to output[index] \\ \hline
    movfr       &   ra      &   index   &   pop front of input[index] \\ \hline
\end{tabular}
\end{table}

\section{Implementation}

\begin{landscape}

\begin{figure}[p]
    \caption{Core diagram}
    \label{fig:core-IV}
    \resizebox{1.05\linewidth}{!}{\input{core-IV.tex}}
\end{figure}

\begin{figure}[p]
    \caption{CMAC configuration}
    \label{fig:core-cmac}
    \resizebox{\linewidth}{!}{\input{core-cmac.tex}}
\end{figure}
\end{landscape}

\subsection{Tools}

\subsubsection{Assembler}

\subsubsection{Test template generator}

Automated testing was used in order to ensure correct execution of the processor and its components.
This was achieved by implementing a test template generator, called \texttt{mktest}.
The program takes a VHDL entity and outputs a corresponding test template.
Inputs and expected outputs could then be added to the template and when run as a simulation, would automatically fail on incorrect output.
This method ensured faster refactoring and the test files also serve as a guarantee of the components behaviour.

Listing \ref{lst:test-template} shows the template generated for the Core entity.

\lstinputlisting[
  language=vhdl,
  label=lst:test-template,
caption={Test template generated for \texttt{Core} by \texttt{mktest}}]
  {core_test_template.vhd}

\subsubsection{Array generator}

Due to the Xilinx tools lack of support for versions of VHDL later than VHDL 1993, a program had to be written in order to generate large configurations of processor cores.
The resulting program, called \texttt{mkarray}, takes a topology and a size as arguments and outputs a VHDL entity.
The entity instantiates the given number of cores, connected according to the given topology.
The entity uses the same interface as the core itself, but leaves the FIFO signals unconnected for the user to connect.

Four configurations were implemented: a one directional chain, a bi-directional chain, a two-dimensional grid pattern with bi-directional communication and a three-dimensional grid pattern with bi-directional communication.
The one directional chain and the 2D grid can be seen in listing \ref{l-mkarray-sample}.

Since the configurations are simply expressed using Python, additional topologies can easily be expressed.

\lstinputlisting[
  language=python,
  label=l-mkarray-sample,
caption={Chain and grid implementations in \texttt{mkarray}}]
  {mkarray-sample.py}

\section{Result}

%- Communication bandwidth and latency
%- Cycle count for programs
%  - FIR
%  - Fibonacci
%  - vector-matrix multiplication (same as FIR essentially)
%- Size with varying number of fifos
%- Clock rate impact with different number of cores

\lstinputlisting[
  label=lst:factorial,
caption={Recursive factorial implementation}]
  {factorial.s}

\lstinputlisting[
  label=lst:fibonacci,
caption={Recursive fibonacci implementation (nops removed for consistency)}]
  {fibonacci.s}

\lstinputlisting[
  label=lst:fir,
caption={Fixed point FIR filter implementation}]
  {fir_filter.s}

\begin{table}
\centering
\caption{Program performance}
\label{t:program-performance}
\newcommand{\const}{\multicolumn{2}{c|}{const}}
\begin{tabular}{| l | l | l | l |}
    \hline
    Program     &   Size (num. instr.)  &   Cycle Count                     &   Exec. Time      \\ \hline
    Fibonacci   &   110                 &   11047 for fib(10)               &                   \\ \hline
    Factorial   &   85                  &   224 for 4!                      &                   \\ \hline
    FIR         &   28                  &   13 setup + 12 outer loop + (4 + taps) inner loop &     \\ \hline
\end{tabular}
\end{table}


\section{Discussion}

%- Pipeline too long with no benefit (extra hardware)
%- Low clock frequency
%- Instruction set should be bigger (compare, bitwise ops)
%- More advanced tools
%- Additional adder in order to do more efficient pops
\subsection{Missing functionality}

Although the processor used the arithmetic operations of the DSP48E1 slice effectively, it did not take advantage of its bitwise operations.
These would have been a useful addition for applications like cryptography where the exclusive-or operation is frequently used.

%- Simultaneous multi threading because nops

\section{Conclusion}

\printbibliography

\end{document}
