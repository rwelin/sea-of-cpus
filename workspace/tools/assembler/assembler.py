#!/usr/bin/env python
import argparse
import os

opcodes = {}

def fail(error, line, num):
    print("%s error on line %d: '%s'" % (error, num, line))
    exit()

def to_binary(num, length):
    return '{0:b}'.format(num).zfill(length)

def encode_argument(arg, length):
    if arg[0] == 'R':
        return to_binary(int(arg[1:]), length)
    else:
        return to_binary(int(arg), length)

def encode(line, num):
    words = line.split()

    try:
        op = opcodes[words[0]]

        if len(words) == 2:
            arg = words[1]
            return op + encode_argument(arg, 12)
        elif len(words) == 3:
            data1 = encode_argument(words[1], 6)
            data2 = encode_argument(words[2], 6)
            return op + data1 + data2
        else:
            fail('Argument', line, num)

    except KeyError:
        fail('Instruction', line, num)

def main():
    parser = argparse.ArgumentParser(prog = 'assembler')
    parser.add_argument('opcodes')
    parser.add_argument('assembly_code')
    args = parser.parse_args()

    package = os.path.basename(os.path.splitext(args.assembly_code)[0])

    with open(args.opcodes) as text:
        i = 0
        for line in text:
            words = line.split()
            mnemonic = words[0].upper()
            opcodes[mnemonic] = to_binary(i, 6)
            i = i + 1

    machine_instructions = []

    with open(args.assembly_code) as text:
        i = 1
        for line in text:
            machine_instructions += [ '"%s"' % encode(line[:-1].upper(), i) ]
            i = i + 1

    print("-- Generated by assembler from %s" % os.path.basename(args.assembly_code))

    print("""library work;
use work.core_interface.all;

package %s is""" % package)

    print("""
    type program is array (0 to %d) of word;
    constant %s_code: program := {""" % (len(machine_instructions) - 1, package))

    print('        %s' % ',\n        '.join(machine_instructions))

    print("""    };

end package %s;""" % package)

if __name__ == "__main__":
    main()
