#!/usr/bin/env python
import argparse
import os
import re

registers = [ 'R' + str(x) for x in range(0, 64) ]
labels = dict()

class OperandError(Exception):
    def __init__(self, message):
        super(OperandError, self).__init__(message)
        self.message = message

class ReservedKeywordError(Exception):
    def __init__(self, name):
        msg = '{} is a keyword'.format(name)
        super(ReservedKeywordError, self).__init__(msg)
        self.message = msg

def fail(error, line, num, msg=''):
    print("{} error on line {}: '{}'".format(error, num+1, line))
    if msg:
        print(msg)
    exit()

def sign_extend(num, length):
    if num[0] == '-':
        return '1'*(length-len(num)+1) + num[1:]
    else:
        return num.zfill(length)

def to_binary(num, length):
    return sign_extend('{0:b}'.format(num), length)

def is_label(word):
    return re.search(r'^\w+:$', word)

def is_reserved(token):
    return token in registers

def is_number(token):
    return re.search(r'^-?(0|[1-9][0-9]*)$', token)

def encode_argument(arg, length):
    if arg in registers:
        return to_binary(int(arg[1:]), 6) + '0'*(length-6)
    elif is_number(arg):
        return to_binary(int(arg), length)
    elif arg in labels:
        return to_binary(int(labels[arg]), length)
    else:
        raise OperandError("Argument '{}' has unknown type.".format(arg))

def strip_comment(line):
    try:
        return line[:line.index(';')]
    except ValueError:
        return line

# Takes an assembly program as text and returns a list of assembly lines
# without comments or unnecessary whitespace.
def asm_lines(text):
    asm = []
    for line in text:
        ws_less = ' '.join(strip_comment(line).upper().split())
        if ws_less:
            asm.append(ws_less)
    return asm

# Returns a bit string encoded machine instruction.
def encode(instr, opcodes):
    if len(instr) == 1:
        if is_number(instr[0]):
            return to_binary(int(instr[0]), 18)
        else:
            return opcodes[instr[0]] + encode_argument('0', 12)
    elif len(instr) == 2:
        arg = instr[1]
        return opcodes[instr[0]] + encode_argument(arg, 12)
    elif len(instr) == 3:
        data1 = encode_argument(instr[1], 6)
        data2 = encode_argument(instr[2], 6)
        return opcodes[instr[0]] + data1 + data2
    else:
        raise OperandError('Too many operands.')

# Parse instruction set definition and produce a dictionary of opcodes.
def parse_opcodes(filename):
    opcodes = {}
    with open(filename) as text:
        i = 0
        for line in text:
            words = line.split()
            mnemonic = words[0].upper()
            opcodes[mnemonic] = to_binary(i, 6)
            i = i + 1
    return opcodes

# Prints the machine code as an array in a vhdl package.
def output_vhdl(filename, machine_code):
    package = os.path.basename(os.path.splitext(filename)[0])

    print('-- Generated by assembler from {}'.format(os.path.basename(filename)))
    print('library work;')
    print('use work.core_config.all;')
    print()
    print('package {} is'.format(package))
    print()
    print('    type program is array (0 to {}) of word;'.format(len(machine_code) - 1))
    print('    constant {}_code: program := ('.format(package))
    print('        {}'.format(',\n        '.join(machine_code)))
    print('    );')
    print()
    print('end package {};'.format(package))

def main():
    parser = argparse.ArgumentParser(prog = 'assembler')
    parser.add_argument('opcodes')
    parser.add_argument('assembly_code')
    args = parser.parse_args()

    opcodes = parse_opcodes(args.opcodes)

    machine_instructions = []

    # Parse assembly code and produce machine instructions.
    with open(args.assembly_code) as text:
        asm = asm_lines(text)

        for i,line in enumerate(asm):
            tokens = line.split()
            if is_label(tokens[0]):
                # Record label
                name = tokens[0][:-1]
                if is_reserved(name):
                    fail('Reserved keyword', line, i, "'{}' is a reserved keyword".format(name))
                if name in labels:
                    fail('Existing label', line, i, "Label '{}' is already defined as address {}".format(name, labels[name]))

                location = i-len(labels)
                labels[name] = location

        for i,line in enumerate(asm):
            tokens = line.split()

            if is_label(tokens[0]):
                tokens = tokens[1:]

            if tokens:
                # Line contains an instruction
                try:
                    instr = encode(tokens, opcodes)
                except KeyError:
                    fail('Instruction', line, i)
                except OperandError as msg:
                    fail('Operand', line, i, msg)

                machine_instructions.append('"{}"'.format(instr))

    output_vhdl(args.assembly_code, machine_instructions)

if __name__ == "__main__":
    main()
