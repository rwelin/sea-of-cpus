-- Template generated by mktest from BlockRam.vhd
library ieee;
use ieee.std_logic_1164.all;
use work.BlockRam;
use work.core_config.all;
use work.test.all;

entity BlockRamTest is
end entity BlockRamTest;

architecture behav of BlockRamTest is
    signal clk: std_logic;
    signal reset: std_logic;
    signal addra: ram_addr;
    signal addrb: ram_addr;
    signal dia: word;
    signal dib: word;
    signal doa: word;
    signal dob: word;
    signal wea: std_logic;
    signal web: std_logic;

    type TestData is
        record
            reset: std_logic;
            addra: ram_addr;
            addrb: ram_addr;
            dia: word;
            dib: word;
            doa: word;
            dob: word;
            wea: std_logic;
            web: std_logic;
            wait_cycles: integer;
        end record;

    type TestDataArray is array (0 to 4) of TestData;
    constant test_data: TestDataArray := (
        0 => -- `output' should be zero on reset
            ('1', (others => '0'), (others => '0'), (others => '0'), (others => '0'),
             (others => '0'), (others => '0'), '0', '0', 2),

        1 => -- `output' should be synchronously written to when `wea' and `web' are set
            ('0', uint2slv(1, addra'length), uint2slv(2, addrb'length), uint2slv(1, dia'length), uint2slv(2, dib'length),
             uint2slv(0, doa'length), uint2slv(0, dob'length), '1', '1', 0),

        2 => -- ditto
            ('0', uint2slv(1, addra'length), uint2slv(2, addrb'length), uint2slv(1, dia'length), uint2slv(2, dib'length),
             uint2slv(0, doa'length), uint2slv(0, dob'length), '1', '1', 1),

        3 => -- ditto
            ('0', uint2slv(1, addra'length), uint2slv(2, addrb'length), uint2slv(1, dia'length), uint2slv(2, dib'length),
             uint2slv(1, doa'length), uint2slv(2, dob'length), '1', '1', 1),

        4 => -- the block ram should not be written to when `wea' and `web' are cleared
            ('0', uint2slv(1, addra'length), uint2slv(2, addrb'length), uint2slv(5, dia'length), uint2slv(6, dib'length),
             uint2slv(1, doa'length), uint2slv(2, dob'length), '0', '0', 2)
    );

begin

    clk_gen: process
    begin
        clk <= '1';
        wait for 50 ns;
        clk <= '0';
        wait for 50 ns;
    end process clk_gen;

    BlockRam_inst: entity BlockRam
    port map (
        clk => clk,
        reset => reset,
        addra => addra,
        addrb => addrb,
        dia => dia,
        dib => dib,
        doa => doa,
        dob => dob,
        wea => wea,
        web => web
    );

    BlockRam_test: process
    begin
        wait until clk'event and clk = '1';

        for i in test_data'range loop

            reset <= test_data(i).reset;
            addra <= test_data(i).addra;
            addrb <= test_data(i).addrb;
            dia <= test_data(i).dia;
            dib <= test_data(i).dib;
            wea <= test_data(i).wea;
            web <= test_data(i).web;

            wait_for(test_data(i).wait_cycles, clk);

            assert doa = test_data(i).doa
            report "Test " & integer'image(i) & ":" &
                " read_a is " & to_string(doa) &
                " should be " & to_string(test_data(i).doa)
            severity failure;

            assert dob = test_data(i).dob
            report "Test " & integer'image(i) & ":" &
                " read_a is " & to_string(dob) &
                " should be " & to_string(test_data(i).dob)
            severity failure;

        end loop;

        report "DONE" severity failure;
    end process BlockRam_test;

end architecture behav;
